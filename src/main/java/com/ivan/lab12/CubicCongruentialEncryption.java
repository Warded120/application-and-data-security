package com.ivan.lab12;

import com.ivan.utils.FileManager;
import java.io.*;
import java.nio.charset.StandardCharsets;

public class CubicCongruentialEncryption {
    private static final long KEY_SIZE_BYTES = 12_600_000; // 100 Mbit = 12.5 MB
    private static final int BUFFER_SIZE = 8192; // 8 KB buffer for file operations
    private static final long MODULUS = 4294967291L; // Large prime number (2^32 - 5)
    private static final long A = 12345L; // Coefficients for CCG
    private static final long B = 67890L;
    private static final long C = 54321L;
    private static final long D = 98765L;

    /**
     * Cubic Congruential Generator to produce pseudorandom sequence.
     */
    private static class CCG {
        private long state;

        public CCG(long seed) {
            this.state = seed;
        }

        public byte nextByte() {
            // Cubic congruential formula: x_{n+1} = (a*x_n^3 + b*x_n^2 + c*x_n + d) mod m
            state = (A * state % MODULUS * state % MODULUS * state % MODULUS +
                     B * state % MODULUS * state % MODULUS +
                     C * state + D) % MODULUS;
            return (byte) (state & 0b11111111); // Take least significant byte
        }
    }

    /**
     * Generates a pseudorandom key of 100 Mbit (12.5 MB) using CCG and saves it to a file.
     * @param keyFilePath Path to save the key file
     * @param asText If true, saves as text ("0" and "1"); if false, saves as binary
     */
    public static void generateKey(String keyFilePath, boolean asText) throws IOException {
        CCG generator = new CCG(System.currentTimeMillis()); // Seed with current time
        byte[] key = new byte[(int) KEY_SIZE_BYTES];

        // Generate key using CCG
        for (int i = 0; i < KEY_SIZE_BYTES; i++) {
            key[i] = generator.nextByte();
        }

        if (asText) {
            // Convert binary to text ("0" and "1")
            StringBuilder binaryString = new StringBuilder((int) KEY_SIZE_BYTES * 8);
            for (byte b : key) {
                for (int i = 7; i >= 0; i--) {
                    binaryString.append((b >> i) & 1);
                }
            }
            FileManager.writeLargeFile(keyFilePath, binaryString.toString());
        } else {
            // Save as binary
            FileManager.writeLargeBinaryFile(keyFilePath, key);
        }
    }

    /**
     * Encrypts or decrypts a file using XOR with a key file generated by CCG.
     * @param inputFilePath Path to the input file (100 Mbit)
     * @param keyFilePath Path to the key file (binary or text)
     * @param outputFilePath Path to save the output file
     * @param keyIsText If true, key file is text ("0" and "1"); if false, binary
     * @param asTextOutput If true, output is text ("0" and "1"); if false, binary
     */
    public static void encryptFile(String inputFilePath, String keyFilePath,
                                   String outputFilePath, boolean keyIsText,
                                   boolean asTextOutput) throws IOException {
        // Read key
        byte[] keyBytes = FileManager.readLargeBinaryFile(keyFilePath);
        if (keyIsText) {
            String keyText = FileManager.readLargeFile(keyFilePath);
            if (keyText.length() != KEY_SIZE_BYTES * 8) {
                throw new IllegalArgumentException("Text key file must contain exactly 100 Mbit");
            }
            keyBytes = new byte[(int) KEY_SIZE_BYTES];
            for (int i = 0; i < KEY_SIZE_BYTES; i++) {
                String byteString = keyText.substring(i * 8, (i + 1) * 8);
                keyBytes[i] = (byte) Integer.parseInt(byteString, 2);
            }
        }
        
        // Validate input file size (100 Mbit = 12.5 MB)
        File inputFile = new File(inputFilePath);
        if (inputFile.length() != KEY_SIZE_BYTES) {
            throw new IllegalArgumentException("Input file must be exactly 100 Mbit (12.5 MB)");
        }

        // Process file with XOR
        try (FileInputStream fis = new FileInputStream(inputFile);
             OutputStream fos = asTextOutput ? new FileOutputStream(outputFilePath) : new FileOutputStream(outputFilePath)) {
            byte[] buffer = new byte[BUFFER_SIZE];
            int keyIndex = 0;
            int bytesRead;

            while ((bytesRead = fis.read(buffer)) != -1) {
                // XOR with key
                for (int i = 0; i < bytesRead; i++) {
                    buffer[i] = (byte) (buffer[i] ^ keyBytes[keyIndex]);
                    keyIndex = (keyIndex + 1) % keyBytes.length;
                }

                if (asTextOutput) {
                    // Convert to text ("0" and "1")
                    StringBuilder binaryString = new StringBuilder(bytesRead * 8);
                    for (int i = 0; i < bytesRead; i++) {
                        for (int j = 7; j >= 0; j--) {
                            binaryString.append((buffer[i] >> j) & 1);
                        }
                    }
                    fos.write(binaryString.toString().getBytes(StandardCharsets.UTF_8));
                } else {
                    // Write binary output
                    fos.write(buffer, 0, bytesRead);
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        // Generate key
        generateKey("key.bin", false);
        generateKey("input.bin", false);

        // Encrypt and decrypt
        FileManager.writeLargeBinaryFile("input.bin", new byte[(int) KEY_SIZE_BYTES]); // Dummy input
        encryptFile("input.bin", "key.bin", "encrypted.bin", false, false); // Encrypt to binary
    }
}